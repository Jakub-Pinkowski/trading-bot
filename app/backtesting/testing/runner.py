from datetime import datetime

from app.backtesting.cache.dataframe_cache import dataframe_cache, get_cached_dataframe
from app.backtesting.cache.indicators_cache import indicator_cache
from app.backtesting.metrics.per_trade_metrics import calculate_trade_metrics
from app.backtesting.metrics.summary_metrics import SummaryMetrics
from app.backtesting.testing.utils.dataframe_validators import validate_dataframe, MIN_ROWS_FOR_BACKTEST
from app.utils.logger import get_logger

logger = get_logger('backtesting/testing/runner')


# ==================== Single Test Execution ====================

def run_single_test(test_params):
    """Run a single test with the given parameters."""
    # Unpack parameters
    tested_month, symbol, interval, strategy_name, strategy_instance, verbose, switch_dates, filepath = test_params

    # Track cache stats before the test
    ind_hits_before = indicator_cache.hits
    ind_misses_before = indicator_cache.misses
    df_hits_before = dataframe_cache.hits
    df_misses_before = dataframe_cache.misses

    try:
        df = get_cached_dataframe(filepath)
    except Exception as error:
        logger.error(f'Failed to read file: {filepath}\nReason: {error}')
        return None

    # Comprehensive DataFrame validation
    if not validate_dataframe(df, filepath):
        return None

    # Check for the minimum row count required for reliable backtesting
    if len(df) < MIN_ROWS_FOR_BACKTEST:
        logger.warning(
            f'DataFrame has only {len(df)} rows, need at least {MIN_ROWS_FOR_BACKTEST} '
            f'for reliable backtesting in {filepath}'
        )
        # Continue anyway but log warning - some strategies may still work with fewer rows

    if verbose:
        print(f'\nRunning strategy: {strategy_name} for {symbol} {interval} {tested_month}', flush=True)

    trades_list = strategy_instance.run(df, switch_dates)

    trades_with_metrics_list = [calculate_trade_metrics(trade, symbol) for trade in trades_list]

    if trades_with_metrics_list:
        metrics = SummaryMetrics(trades_with_metrics_list)
        summary_metrics = metrics.calculate_all_metrics()

        # Calculate cache stats for this test
        ind_hits_delta = indicator_cache.hits - ind_hits_before
        ind_misses_delta = indicator_cache.misses - ind_misses_before
        df_hits_delta = dataframe_cache.hits - df_hits_before
        df_misses_delta = dataframe_cache.misses - df_misses_before

        result = {
            'month': tested_month,
            'symbol': symbol,
            'interval': interval,
            'strategy': strategy_name,
            'metrics': summary_metrics,
            'timestamp': datetime.now().isoformat(),
            'cache_stats': {
                'ind_hits': ind_hits_delta,
                'ind_misses': ind_misses_delta,
                'df_hits': df_hits_delta,
                'df_misses': df_misses_delta,
            }
        }
        return result
    else:
        if verbose:
            print(f'No trades generated by strategy {strategy_name} for {symbol} {interval} {tested_month}', flush=True)

        logger.info(f'No trades generated by strategy {strategy_name} for {symbol} {interval} {tested_month}')

        # Calculate cache stats for this test
        ind_hits_delta = indicator_cache.hits - ind_hits_before
        ind_misses_delta = indicator_cache.misses - ind_misses_before
        df_hits_delta = dataframe_cache.hits - df_hits_before
        df_misses_delta = dataframe_cache.misses - df_misses_before

        # Return a complete result dictionary even when no trades are generated
        return {
            'month': tested_month,
            'symbol': symbol,
            'interval': interval,
            'strategy': strategy_name,
            'metrics': {},  # Empty metrics
            'timestamp': datetime.now().isoformat(),
            'cache_stats': {
                'ind_hits': ind_hits_delta,
                'ind_misses': ind_misses_delta,
                'df_hits': df_hits_delta,
                'df_misses': df_misses_delta,
            }
        }
